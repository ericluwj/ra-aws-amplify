{"version":3,"file":"ra-aws-amplify.cjs.production.min.js","sources":["../src/buildAmplifyProvider/getFinalType.ts","../src/buildAmplifyProvider/buildVariables.ts","../src/buildAmplifyProvider/getResponseParser.ts","../src/buildAmplifyProvider/buildQuery.ts","../src/buildAmplifyProvider/buildGqlQuery.ts","../src/buildAmplifyProvider/buildAmplifyProvider.ts","../src/buildAmplifyProvider/createClient.ts","../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/AmplifyAuthProvider/AmplifyAuthProvider.tsx","../src/AmplifyPagination/reducer.ts","../src/fields/S3Field.tsx","../src/fields/S3File.tsx","../src/fields/S3FileField.tsx","../src/fields/S3Image.tsx","../src/fields/S3ImageField.tsx","../src/inputs/S3Input.tsx","../src/inputs/S3FileInput.tsx","../src/index.ts","../src/AmplifyPagination/AmplifyPagination.tsx","../src/inputs/S3ImageInput.tsx","../src/buildAmplifyProvider/useAmplifyDataProvider.ts","../src/buildAmplifyProvider/getAuthType.ts"],"sourcesContent":["import { TypeKind } from 'graphql';\n\n/**\n * Ensure we get the real type even if the root type is NON_NULL or LIST\n * @param {GraphQLType} type\n */\nconst getFinalType = (type: any): any => {\n  if (type?.kind === TypeKind.NON_NULL || type?.kind === TypeKind.LIST) {\n    return getFinalType(type.ofType);\n  }\n\n  return type;\n};\n\nexport default getFinalType;\n","import { S3Object } from '../types';\n/* eslint-disable default-case */\nimport {\n  GET_LIST,\n  GET_ONE,\n  GET_MANY,\n  GET_MANY_REFERENCE,\n  CREATE,\n  UPDATE,\n  DELETE,\n} from 'ra-core';\n\nimport getFinalType from './getFinalType';\nimport isList from './isList';\n\nconst sanitizeValue = (type: any, value: any) => {\n  if (type.name === 'Int') {\n    return parseInt(value, 10);\n  }\n\n  if (type.name === 'Float') {\n    return parseFloat(value);\n  }\n\n  return value;\n};\n\nconst castType = (value: any, type: any) => {\n  switch (`${type.kind}:${type.name}`) {\n    case 'SCALAR:Int':\n      return Number(value);\n\n    case 'SCALAR:String':\n      return String(value);\n\n    case 'SCALAR:Boolean':\n      return Boolean(value);\n\n    default:\n      return value;\n  }\n};\n\nconst cleanS3Object = (input: S3Object) => {\n  const fields = ['key', 'level', 'identityId', 'region', 'bucket'];\n  return Object.entries(input).reduce(\n    (acc: any, [k, v]: [string, unknown]): Record<string, string> => {\n      if (fields.includes(k)) {\n        acc[k] = v;\n      }\n      return acc;\n    },\n    {}\n  );\n};\n\nconst prepareParams = (\n  params: any,\n  queryType: any,\n  introspectionResults: any\n) => {\n  const result: any = {};\n\n  if (!params) {\n    return params;\n  }\n\n  Object.keys(params).forEach(async key => {\n    const param: any = params[key];\n    let arg: any = null;\n\n    if (!param) {\n      result[key] = param;\n      return;\n    }\n\n    if (queryType && Array.isArray(queryType.args)) {\n      arg = queryType.args.find((item: any) => item.name === key);\n    }\n\n    if (param instanceof File || key === 'rawFile') {\n      // file upload should be handled with Storage\n      return;\n    }\n\n    if (param instanceof Date) {\n      result[key] = param.toISOString();\n      return;\n    }\n\n    if (\n      param instanceof Object &&\n      !Array.isArray(param) &&\n      arg &&\n      arg.type.kind === 'INPUT_OBJECT'\n    ) {\n      const args = introspectionResults.types.find(\n        (item: any) =>\n          item.kind === arg.type.kind && item.name === arg.type.name\n      ).inputFields;\n      result[key] = prepareParams(param, { args }, introspectionResults);\n      return;\n    }\n\n    if (\n      param instanceof Object &&\n      (!param as any) instanceof Date &&\n      !Array.isArray(param)\n    ) {\n      result[key] = prepareParams(param, queryType, introspectionResults);\n      return;\n    }\n\n    if (!arg) {\n      result[key] = param;\n      return;\n    }\n\n    result[key] = castType(param, arg.type);\n  });\n\n  return result;\n};\n\n/**\n * This handles filtering and sorting.\n */\nconst buildGetListVariables = (introspectionResults: any) => (\n  resource: any,\n  _aorFetchType: string,\n  params: any\n  ) => {\n  console.log('params: ', params);\n  // console.log(params);\n\n  const { nextToken: token } = params.filter || {};\n  const nextToken = token && params.pagination.page > 1 ? token : undefined;\n  console.log('nextToken: ', nextToken);\n  return {};\n  // return {\n  //   nextToken,\n  // };\n  let variables: any = { filter: {} };\n  if (params.filter) {\n    variables.filter = Object.keys(params.filter).reduce((acc, key) => {\n      if (key === 'ids') {\n        return { ...acc, ids: params.filter[key] };\n      }\n\n      if (typeof params.filter[key] === 'object') {\n        const type = introspectionResults.types.find(\n          (t: any) => t.name === `${resource.type.name}Filter`\n        );\n        const filterSome = type.inputFields.find(\n          (t: any) => t.name === `${key}_some`\n        );\n\n        if (filterSome) {\n          const filter = Object.keys(params.filter[key]).reduce(\n            (acc, k) => ({\n              ...acc,\n              [`${k}_in`]: params.filter[key][k],\n            }),\n            {}\n          );\n          return { ...acc, [`${key}_some`]: filter };\n        }\n      }\n\n      const parts = key.split('.');\n\n      if (parts.length > 1) {\n        if (parts[1] === 'id') {\n          const type = introspectionResults.types.find(\n            (t: any) => t.name === `${resource.type.name}Filter`\n          );\n          const filterSome = type.inputFields.find(\n            (t: any) => t.name === `${parts[0]}_some`\n          );\n\n          if (filterSome) {\n            return {\n              ...acc,\n              [`${parts[0]}_some`]: { id: params.filter[key] },\n            };\n          }\n\n          return { ...acc, [parts[0]]: { id: params.filter[key] } };\n        }\n\n        const resourceField = resource.type.fields.find(\n          (f: any) => f.name === parts[0]\n        );\n        const type = getFinalType(resourceField.type);\n        return {\n          ...acc,\n          [key]: sanitizeValue(type, params.filter[key]),\n        };\n      }\n\n      const resourceField = resource.type.fields.find(\n        (f: any) => f.name === key\n      );\n\n      if (resourceField) {\n        const type = getFinalType(resourceField.type);\n        const isAList = isList(resourceField.type);\n\n        if (isAList) {\n          return {\n            ...acc,\n            [key]: Array.isArray(params.filter[key])\n              ? params.filter[key].map((value: any) =>\n                  sanitizeValue(type, value)\n                )\n              : sanitizeValue(type, [params.filter[key]]),\n          };\n        }\n\n        return {\n          ...acc,\n          [key]: sanitizeValue(type, params.filter[key]),\n        };\n      }\n\n      return { ...acc, [key]: params.filter[key] };\n    }, {});\n  }\n\n  if (params.pagination) {\n    variables.page = parseInt(params.pagination.page, 10) - 1;\n    variables.perPage = parseInt(params.pagination.perPage, 10);\n  }\n\n  if (params.sort) {\n    variables.sortField = params.sort.field;\n    variables.sortOrder = params.sort.order;\n  }\n\n  return variables;\n};\n\n/**\n * This handles sanitisation of upload data.\n */\nconst buildCreateUpdateVariables = (introspectionResults: any) => (\n  // unused, left for code cohesion. Can remove in future iterations if unused.\n  _resource: any,\n  _fetchType: any,\n  // used arguments\n  params: any,\n  queryType: any\n) => {\n  /** Get the accepted arguments from the schema introspection */\n  const inputArgument = queryType.args.find((a: any) => a.name === 'input');\n  const inputTypeName = getFinalType(inputArgument.type);\n  const { inputFields } = introspectionResults.types.find(\n    (t: any) => t.name === inputTypeName.name\n  );\n\n  /** Generate GraphQL input */\n  const input = Object.keys(params.data).reduce((acc, key) => {\n    /** Get the input field (i.e. CreatePostInput) for validation */\n    const inputField = inputFields.find((f: any) => f.name === key);\n\n    /** Skip any params passed that are not an input field */\n    if (\n      !inputField ||\n      !inputFields.find((f: any) => f.name === inputField.name)\n    ) {\n      return acc;\n    }\n\n    /** Strip any S3Objects of unnecessary fields, pulling only what we need. */\n    if (getFinalType(inputField.type).name?.match(/S3Object/i)) {\n      /** S3Object fields could be an array. */\n      const cleanS3Param = Array.isArray(params.data[key])\n        ? params.data[key].map(cleanS3Object)\n        : cleanS3Object(params.data[key]);\n\n      return {\n        ...acc,\n        [key]: cleanS3Param,\n      };\n    }\n\n    return {\n      ...acc,\n      [key]: params.data[key],\n    };\n  }, {});\n\n  return { input };\n};\n\nexport default (introspectionResults: any) => (\n  resource: any,\n  aorFetchType: string,\n  params: any,\n  queryType: any\n) => {\n  const preparedParams = prepareParams(params, queryType, introspectionResults);\n\n  switch (aorFetchType) {\n    case GET_LIST: {\n      return buildGetListVariables(introspectionResults)(\n        resource,\n        aorFetchType,\n        preparedParams\n      );\n    }\n    case GET_MANY:\n      return (preparedParams.ids as []).reduce(\n        (acc: Record<string, string>, id: string, i: number) => {\n          acc[`id${i}`] = id;\n          return acc;\n        },\n        {}\n      );\n    // return {\n    //   limit: params.ids.length,\n    //   filter: {\n    //     or: params.ids.map((id: string | number) => ({ id: { eq: id } })),\n    //   },\n    // };\n    case GET_MANY_REFERENCE:\n      // grab the arg the secondary GSI key is searching for an use that\n      // as the param in our query.\n      const query = introspectionResults.queries.find(\n        (q: any) => q.name === params.target\n      );\n      if (!query) {\n        throw Error(\n          `Couldn't find a query for ${params.target}. Did you forget to add a param queryField to your @key directive for ${params.target}? See https://github.com/mayteio/ra-aws-amplify#a-post-with-comments-using-the-referencemanyfield-`\n        );\n      }\n      const key = query.args[0].name;\n\n      return {\n        limit: preparedParams.pagination.perPage,\n        [key]: preparedParams.id,\n      };\n\n    case GET_ONE:\n      return { id: preparedParams.id };\n    case DELETE:\n      return {\n        input: { id: preparedParams.id },\n      };\n    case CREATE:\n    case UPDATE: {\n      return buildCreateUpdateVariables(introspectionResults)(\n        resource,\n        aorFetchType,\n        preparedParams,\n        queryType\n      );\n    }\n  }\n};\n","import { GET_LIST, GET_MANY_REFERENCE } from 'ra-core';\n\nexport const LARGE_TOTAL = 9999;\n\nconst sanitizeResource = (data: any) => {\n  const result: any = Object.keys(data).reduce((acc, key) => {\n    if (key.startsWith('_')) {\n      return acc;\n    }\n\n    const dataKey = data[key];\n\n    if (dataKey === null || dataKey === undefined) {\n      return acc;\n    }\n\n    if (Array.isArray(dataKey)) {\n      if (typeof dataKey[0] === 'object') {\n        return {\n          ...acc,\n          [key]: dataKey.map(sanitizeResource),\n          [`${key}Ids`]: dataKey.map(d => d.id),\n        };\n      } else {\n        return { ...acc, [key]: dataKey };\n      }\n    }\n\n    if (typeof dataKey === 'object') {\n      return {\n        ...acc,\n        ...(dataKey &&\n          dataKey.id && {\n            [`${key}.id`]: dataKey.id,\n          }),\n        [key]: sanitizeResource(dataKey),\n      };\n    }\n\n    return { ...acc, [key]: dataKey };\n  }, {});\n\n  return result;\n};\n\nexport default (_introspectionResults: any) => (\n  aorFetchType: string,\n  resource: any,\n  queryType: any,\n  params: any\n) => (response: any) => {\n  const data = response.data;\n  if (aorFetchType === GET_LIST) {\n    return {\n      data: data[`list${resource.type.name}s`].items.map(sanitizeResource),\n      nextToken: data[`list${resource.type.name}s`].nextToken,\n      total: LARGE_TOTAL,\n    };\n  }\n\n  if (aorFetchType === GET_MANY_REFERENCE) {\n    return {\n      data:\n        data[params.target] && data[params.target].items.map(sanitizeResource),\n      nextToken: data[params.target].nextToken,\n      total: LARGE_TOTAL,\n    };\n  }\n\n  return {\n    data: data[queryType.name] && sanitizeResource(data[queryType.name]),\n    total: LARGE_TOTAL,\n  };\n};\n","import buildVariables from './buildVariables';\nimport { getGqlQuery } from './buildGqlQuery';\nimport getResponseParser from './getResponseParser';\n\nexport const buildQueryFactory = (\n  buildVariablesImpl: any,\n  getGqlQuery: any,\n  getResponseParserImpl: any\n) => ({ queries, mutations }: any) => (introspectionResults: any) => {\n  const knownResources = introspectionResults.resources.map(\n    (r: any) => r.type.name\n  );\n\n  return (aorFetchType: string, resourceName: string, params: any) => {\n    console.log(aorFetchType, resourceName, params);\n    const resource = introspectionResults.resources.find(\n      (r: any) => r.type.name === resourceName\n    );\n\n    if (!resource) {\n      throw new Error(\n        `Unknown resource ${resourceName}. Make sure it has been declared on your server side schema. Known resources are ${knownResources.join(\n          ', '\n        )}`\n      );\n    }\n\n    const queryType = resource[aorFetchType];\n\n    if (!queryType) {\n      throw new Error(\n        `No query or mutation matching fetch type ${aorFetchType} could be found for resource ${resource.type.name}`\n      );\n    }\n\n    const variables = buildVariablesImpl(introspectionResults)(\n      resource,\n      aorFetchType,\n      params,\n      queryType\n    );\n\n    const query = getGqlQuery(introspectionResults)(\n      aorFetchType,\n      resource,\n      params,\n      queries,\n      mutations\n    );\n\n    const parseResponse = getResponseParserImpl(introspectionResults)(\n      aorFetchType,\n      resource,\n      queryType,\n      params\n    );\n\n    return {\n      query,\n      variables,\n      parseResponse,\n    };\n  };\n};\n\nexport default buildQueryFactory(\n  buildVariables,\n  getGqlQuery,\n  getResponseParser\n);\n","import gql from 'graphql-tag';\nimport {\n  GET_LIST,\n  GET_ONE,\n  GET_MANY_REFERENCE,\n  CREATE,\n  UPDATE,\n  DELETE,\n} from 'ra-core';\nexport const getGqlQuery = (_introspectionResults: any) => (\n  raFetchType: string,\n  resource: any,\n  params: any,\n  queries: any,\n  mutations: any\n) => {\n  switch (raFetchType) {\n    case GET_LIST:\n      return gql(queries[`list${resource.type.name}s`]);\n    case GET_ONE:\n      return gql(queries[`get${resource.type.name}`]);\n    case GET_MANY_REFERENCE:\n      const targetQuery = params.target;\n      return gql(queries[targetQuery]);\n    case CREATE:\n      return gql(mutations[`create${resource.type.name}`]);\n    case UPDATE:\n      return gql(mutations[`update${resource.type.name}`]);\n    case DELETE:\n      return gql(mutations[`delete${resource.type.name}`]);\n    default:\n      return undefined;\n  }\n};\n","import merge from 'lodash/merge';\nimport buildGraphQLProvider from 'ra-data-graphql';\nimport {\n  DELETE,\n  DELETE_MANY,\n  UPDATE,\n  UPDATE_MANY,\n  GET_LIST,\n  GET_ONE,\n  GET_MANY,\n  GET_MANY_REFERENCE,\n  CREATE,\n} from 'ra-core';\n\nimport defaultBuildQuery from './buildQuery';\nimport { createClient } from './createClient';\n\nconst SINGLE_OPERATION_MAP: Record<string, string> = {\n  [GET_MANY]: GET_ONE,\n  [UPDATE_MANY]: UPDATE,\n  [DELETE_MANY]: DELETE,\n};\n\nconst defaultOptions = {\n  introspection: {\n    operationNames: {\n      [GET_LIST]: (resource: any) => `list${resource.name}s`,\n      [GET_ONE]: (resource: any) => `get${resource.name}`,\n      [GET_MANY]: (resource: any) => `list${resource.name}s`,\n      [GET_MANY_REFERENCE]: (resource: any) => `list${resource.name}s`,\n      [CREATE]: (resource: any) => `create${resource.name}`,\n      [UPDATE]: (resource: any) => `update${resource.name}`,\n      [DELETE]: (resource: any) => `delete${resource.name}`,\n    },\n    exclude: undefined,\n    include: undefined,\n  },\n};\n\nexport const buildAmplifyProvider = ({\n  queries,\n  mutations,\n  schema,\n  ...options\n}: any) => {\n  const client = createClient({ ...options });\n  const buildQuery = defaultBuildQuery({ queries, mutations, schema });\n  const args = merge({ client, buildQuery }, defaultOptions, options, {\n    introspection: { schema: schema.data.__schema },\n  });\n\n  return buildGraphQLProvider(args).then((defaultDataProvider: any) => {\n    return (fetchType: any, resource: any, params: any) => {\n      // Amplify does not support multiple deletions so instead we send multiple DELETE requests\n      // This can be optimized using the apollo-link-batch-http\n      const { ids, ...otherParams } = params;\n      console.log(`FETCH TYPE: ${fetchType}`);\n      switch (fetchType) {\n        case DELETE_MANY:\n          return Promise.all(\n            params.ids.map((id: string) =>\n              defaultDataProvider(SINGLE_OPERATION_MAP[fetchType], resource, {\n                id,\n                ...otherParams,\n              })\n            )\n          ).then((results) => {\n            const data = results.reduce(\n              (acc: any, _: any, idx: any): any => [...acc, params.ids[idx]],\n              []\n            );\n\n            return { data };\n          });\n        case UPDATE_MANY:\n        case GET_MANY:\n          return Promise.all(\n            params.ids.map((id: string) =>\n              defaultDataProvider(SINGLE_OPERATION_MAP[fetchType], resource, {\n                id,\n                ...otherParams,\n              })\n            )\n          ).then((results) => {\n            const data =\n              fetchType === GET_MANY\n                ? results.map((result: any) => result.data)\n                : results.reduce(\n                    (acc: any, { data }: any): any => [...acc, data.id],\n                    []\n                  );\n\n            return { data };\n          });\n        default:\n          return defaultDataProvider(fetchType, resource, params);\n      }\n    };\n  });\n};\n","import { createAppSyncLink } from 'aws-appsync';\nimport { ApolloClient } from 'apollo-client';\nimport { createHttpLink } from 'apollo-link-http';\nimport { InMemoryCache } from 'apollo-cache-inmemory';\n\nimport { IntrospectionFragmentMatcher } from 'apollo-cache-inmemory';\nimport { createClientOpts } from '../types';\n\nexport const createClient = ({ endpoint, auth }: createClientOpts) => {\n  // create HTTPLink\n  const httpLink = createHttpLink({\n    uri: endpoint,\n  });\n\n  // create AppSyncLink\n  const awsLink = createAppSyncLink(auth);\n\n  const fragmentMatcher: IntrospectionFragmentMatcher = new IntrospectionFragmentMatcher(\n    {\n      introspectionQueryResultData: {\n        __schema: {\n          types: [],\n        },\n      },\n    }\n  );\n\n  return new ApolloClient({\n    link: awsLink.concat(httpLink),\n    cache: new InMemoryCache({ fragmentMatcher }),\n  });\n};\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import React, { useEffect, useState, useContext } from 'react';\nimport Auth, { AuthClass } from '@aws-amplify/auth';\nimport { Hub } from '@aws-amplify/core';\nimport { HubCapsule } from '@aws-amplify/core/lib-esm/Hub';\nimport { CognitoUser } from 'amazon-cognito-identity-js';\n\nexport const NOT_INSIDE_AMPLIFY_PROVIDER =\n  'No AuthenticationContext. Did you forget to wrap your app in <AmplifyProvider />?';\n\n/** Provides the entire Auth object via a hook to use it with hooks. Sugar. */\nconst AmplifyAuthContext = React.createContext<AuthClass | undefined>(\n  undefined\n);\n\n/** Provides just the user object */\nconst UserContext = React.createContext<CognitoUser | undefined>(undefined);\n\n/**\n * This is written specifically for Amplify/Hub, however, you can replace\n * this provider with another provider (say <AzureProvider />) that replicates\n * the API above and everything using useAuth and useUser should just work!\n */\nexport const AmplifyAuthProvider: React.FC = ({ children }) => {\n  // on mount, store the user and listen to hub changes (Amplify's internal)\n  const [user, setUser] = useState<undefined | CognitoUser>(undefined);\n  useEffect(() => {\n    // get user on mount with a immediately invoked function\n    (async () => {\n      try {\n        const user = await Auth.currentAuthenticatedUser();\n        setUser(user === 'not authenticated' ? undefined : user);\n      } catch (error) {\n        // trackBug(error)\n      }\n    })();\n\n    // bind hub listener for auth changes\n    const listener = async ({ payload }: HubCapsule) => {\n      if (payload.event === 'signIn') {\n        try {\n          const user = await Auth.currentAuthenticatedUser();\n          setUser(user);\n        } catch (error) {\n          // trackBug(error)\n        }\n      } else if (payload.event === 'signOut') {\n        setUser(undefined);\n      }\n    };\n    Hub.listen('auth', listener);\n\n    // clean up hub listener\n    return () => {\n      Hub.remove('auth', listener);\n    };\n  }, []);\n\n  /**\n   * Used by react-admin\n   */\n\n  return (\n    <AmplifyAuthContext.Provider value={Auth}>\n      <UserContext.Provider value={user}>{children}</UserContext.Provider>\n    </AmplifyAuthContext.Provider>\n  );\n};\n\nexport function useAuth() {\n  const context = useContext(AmplifyAuthContext);\n  if (!context) throw Error(NOT_INSIDE_AMPLIFY_PROVIDER);\n  return context;\n}\n\nexport function useAuthProvider() {\n  return {\n    /** Signs in either using username and password, or federated if a provider is passed. */\n    login: ({ username, password, provider }: any) =>\n      username && password && !provider\n        ? Auth.signIn(username, password)\n        : Auth.federatedSignIn({ provider }),\n    logout: () => Auth.signOut(),\n    checkAuth: () => Auth.currentSession(),\n    checkError: () => Auth.currentCredentials(),\n    /** Providers permissions for the whole app. identityId is used with S3Input. */\n    getPermissions: () =>\n      Promise.all([Auth.currentSession(), Auth.currentCredentials()]).then(\n        ([session, { identityId }]) => ({\n          claims: { ...session.getIdToken().payload, identityId },\n        })\n      ),\n  };\n}\n\nexport function useUser() {\n  const context = useContext(UserContext);\n  return context;\n}\n","import { CRUD_GET_LIST_SUCCESS } from 'react-admin';\n\nexport const nextTokenReducer = (\n  previousState = null,\n  { type, payload }: any\n) => {\n  // store the crud token when it comes back\n  if (type === CRUD_GET_LIST_SUCCESS) {\n    // console.log(payload);\n\n    return payload.nextToken || null;\n  }\n\n  // remove the nextToken before trying to get a new list\n  // if (type === CRUD_GET_LIST) {\n  //   return null;\n  // }\n  return previousState;\n};\n","import React from 'react';\nimport { Storage } from 'aws-amplify';\nimport { CircularProgress } from '@material-ui/core';\n\ninterface S3ImageFieldProps extends React.ImgHTMLAttributes<HTMLImageElement> {\n  source?: string;\n  record?: Record<string, any>;\n  label?: string;\n  imgProps?: any;\n  addLabel?: boolean;\n}\n\nexport const S3Field: React.FC<S3ImageFieldProps> = ({\n  source,\n  record = {},\n  children,\n  ...props\n}) => {\n  // store the S3 signed URL in state for use in return\n  const [src, set] = React.useState<string | undefined>();\n  const { key, identityId, level } =\n    source && typeof record[source] === 'object' ? record[source] : record;\n\n  // Listen for changes on\n  React.useEffect(() => {\n    if (key && !key.match(/blob|http/i)) {\n      // if level has been passed down, add the appropriate options.\n      const options =\n        level === 'protected' || level === 'private'\n          ? { level, identityId }\n          : {};\n\n      // get the URL and set it in state\n      Storage.get(key, options).then(result => set(result as string));\n    }\n  }, [key, level, identityId]);\n\n  // if there's no source and there is a key, show a loading spinner\n  if (!src && key) {\n    return <CircularProgress data-testid=\"s3-object-loading\" />;\n  }\n\n  // if there's a src, show the field!\n  if (src) {\n    const childProps = {\n      record,\n      source,\n      src,\n      ...props,\n    };\n    // @ts-ignore\n    return React.cloneElement(children, childProps);\n  }\n\n  // otherwise do nothing\n  return null;\n};\n\nS3Field.defaultProps = {\n  addLabel: true,\n};\n","import React from 'react';\nimport { S3Object } from '../types';\n\nimport ImageIcon from '@material-ui/icons/ImageRounded';\nimport MovieIcon from '@material-ui/icons/MovieRounded';\nimport DescriptionIcon from '@material-ui/icons/DescriptionRounded';\nimport { makeStyles, Theme, Link } from '@material-ui/core';\n\nconst getIcon = (type: string) => {\n  switch (type) {\n    case 'image/png':\n    case 'image/gif':\n    case 'image/jpeg':\n    case 'image/jpg':\n      return ImageIcon;\n    case 'video/mp4':\n    case 'video/3gpp':\n    case 'video/quicktime':\n    case 'video/x-msvideo':\n      return MovieIcon;\n    default:\n      return DescriptionIcon;\n  }\n};\n\nconst useStyles = makeStyles((theme: Theme) => ({\n  icon: {\n    marginRight: theme.spacing(1),\n  },\n}));\n\nexport const S3File: React.FC<{\n  record?: Record<string, any>;\n  source?: string;\n}> = ({ record, source }) => {\n  const s3Object: S3Object = (record && source && record[source]) || record;\n  const Icon = getIcon(s3Object.type);\n  const classes = useStyles();\n  return (\n    <>\n      <Icon\n        titleAccess={`Icon for file type ${s3Object.type || 'unknown'}`}\n        className={classes.icon}\n      />\n      <Link\n        href={s3Object.key}\n        title={`Open ${s3Object.key}`}\n        target=\"_blank\"\n      >{`${s3Object.key}${s3Object.level ? ` - ${s3Object.level}` : ''}`}</Link>\n    </>\n  );\n};\n","import React from 'react';\nimport { S3File } from './S3File';\nimport { S3Field } from './S3Field';\n\ninterface S3FileFieldProps {\n  record?: Record<string, any>;\n  source?: string;\n}\n\nexport const S3FileField: React.FC<S3FileFieldProps> = props => {\n  return (\n    <S3Field {...props}>\n      <S3File />\n    </S3Field>\n  );\n};\n","import React from 'react';\nimport { S3ImageFieldProps } from './S3ImageField';\nimport { S3Object } from '../types';\n\nexport const S3Image: React.FC<S3ImageFieldProps & { src?: string }> = ({\n  src,\n  record,\n  source,\n  imgProps,\n}) => {\n  const s3Object: S3Object = (record && source && record[source]) || record;\n  return s3Object && src ? (\n    <img src={src} title={s3Object.key} {...imgProps} />\n  ) : null;\n};\n","import React from 'react';\nimport { S3Field } from './S3Field';\nimport { S3Image } from './S3Image';\n\nexport interface S3ImageFieldProps {\n  record?: Record<string, any>;\n  source?: string;\n  imgProps?: any;\n  addLabel?: boolean;\n}\n\nexport const S3ImageField: React.FC<S3ImageFieldProps> = ({\n  // to avoid html img prop errors\n  imgProps = {},\n  ...props\n}) => {\n  return (\n    <S3Field {...props}>\n      <S3Image imgProps={imgProps} />\n    </S3Field>\n  );\n};\n\nS3ImageField.defaultProps = {\n  addLabel: true,\n};\n","import React from 'react';\nimport { useInput, useNotify, usePermissions } from 'react-admin';\nimport { Storage } from 'aws-amplify';\nimport { uuid } from 'uuidv4';\nimport { S3Object } from '../types';\n\ninterface S3InputProps {\n  source: string;\n  dropzoneOptions?: any;\n  multiple?: boolean;\n  level?: 'public' | 'protected' | 'private' | undefined;\n}\n\nexport const S3Input: React.FC<S3InputProps> = ({\n  source,\n  dropzoneOptions = {},\n  level,\n  children,\n  ...props\n}) => {\n  // we use permissions to grab the identityId\n  const { permissions } = usePermissions();\n  const { input } = useInput({ source });\n  const notify = useNotify();\n\n  /**\n   * Handle the react-dropzone onDrop\n   * @param {File[]} files files dropped onto the upload area\n   */\n  const onDrop = async (files: File[]) => {\n    try {\n      const results = await Promise.all(\n        files.map(file => {\n          const nameParts = file.name.split('.');\n          return Storage.put(\n            `${nameParts[0]}-${uuid()\n              .split('-')\n              .slice(0, 2)\n              .join('-')}.${nameParts[1]}`,\n            file\n          ).then((result: any) => {\n            let value: S3Object = {\n              key: result.key,\n              type: file.type,\n              level: null,\n              identityId: null,\n            };\n            if (level === 'protected' || level === 'private') {\n              value.identityId = permissions.claims.identityId;\n              value.level = level;\n            }\n            return value;\n          });\n        })\n      );\n\n      if (props.multiple) {\n        input.onChange(results);\n      } else {\n        input.onChange(results[0]);\n      }\n    } catch (error) {\n      input.onChange(undefined);\n      notify('There was an error uploading your files.');\n    }\n  };\n\n  const childProps = {\n    source,\n    options: { onDrop, ...dropzoneOptions },\n    ...props,\n  };\n\n  // @ts-ignore\n  return React.cloneElement(children, childProps);\n};\n","import React from 'react';\nimport { FileInput } from 'react-admin';\nimport { S3Input } from './S3Input';\nimport { S3FileField } from '../fields';\n\nimport { makeStyles } from '@material-ui/core';\n\ninterface S3InputProps {\n  source: string;\n  dropzoneOptions?: any;\n  label?: string;\n  level?: 'public' | 'protected' | 'private' | undefined;\n}\n\nconst useStyles = makeStyles({\n  fileInput: {\n    '& .previews > div': {\n      display: 'flex',\n      alignItems: 'center',\n    },\n  },\n});\n\nexport const S3FileInput: React.FC<S3InputProps> = props => {\n  // S3Input clones the element and injects the logic as props\n  const classes = useStyles();\n  return (\n    <S3Input {...props}>\n      <FileInput className={classes.fileInput}>\n        <S3FileField source={props.source} />\n      </FileInput>\n    </S3Input>\n  );\n};\n","export * from './buildAmplifyProvider';\nexport * from './AmplifyPagination';\nexport * from './AmplifyAuthProvider';\n\nexport * from './fields';\nexport * from './inputs';\n\nimport { nextTokenReducer } from './AmplifyPagination';\nexport const reducers = {\n  nextToken: nextTokenReducer,\n};\n","import React from 'react';\nimport { Button } from '@material-ui/core';\nimport ChevronLeft from '@material-ui/icons/ChevronLeft';\nimport ChevronRight from '@material-ui/icons/ChevronRight';\nimport Toolbar from '@material-ui/core/Toolbar';\n\nimport { useSelector } from 'react-redux';\n\nexport function AmplifyPagination(props: any) {\n  const nextToken = useSelector<any>(state => state.nextToken);\n  if (props.page === 1 && !nextToken) {\n    return null;\n  }\n\n  // useEffect(() => {\n  //   // setFilter((prev: any) => ({ ...prev, nextToken }));\n  // }, [nextToken]);\n\n  return (\n    <Toolbar>\n      {props.page > 1 && (\n        <Button\n          color=\"primary\"\n          key=\"prev\"\n          startIcon={<ChevronLeft />}\n          onClick={() => props.setPage(props.page - 1)}\n        >\n          Prev\n        </Button>\n      )}\n      {nextToken && (\n        <Button\n          color=\"primary\"\n          key=\"next\"\n          endIcon={<ChevronRight />}\n          onClick={() => props.setPage(props.page + 1)}\n        >\n          Next\n        </Button>\n      )}\n    </Toolbar>\n  );\n}\n","import React from 'react';\nimport { ImageInput } from 'react-admin';\nimport { S3Input } from './S3Input';\nimport { S3ImageField } from '../fields';\n\ninterface S3InputProps {\n  source: string;\n  dropzoneOptions?: any;\n  label?: string;\n  level?: 'public' | 'protected' | 'private' | undefined;\n}\n\nexport const S3ImageInput: React.FC<S3InputProps> = props => {\n  return (\n    <S3Input {...props}>\n      <ImageInput>\n        <S3ImageField source={props.source} />\n      </ImageInput>\n    </S3Input>\n  );\n};\n","import { DataProvider } from 'ra-core';\nimport { AUTH_TYPE } from 'aws-appsync-auth-link';\nimport { useState, useEffect } from 'react';\n\nimport { useUser } from '../AmplifyAuthProvider';\nimport { buildAmplifyProvider } from './buildAmplifyProvider';\nimport { getAuthType } from './getAuthType';\n\ninterface useDataProviderArgs {\n  config: Record<string, any>;\n  authType?: AUTH_TYPE | undefined;\n  queries: any;\n  mutations: any;\n  schema: any;\n  // schema: {\n  //   data: IntrospectionResultData | any;\n  // };\n}\n\nexport function useAmplifyDataProvider({\n  config,\n  schema,\n  queries,\n  mutations,\n  authType = undefined,\n}: useDataProviderArgs): any {\n  const [dataProvider, setDataProvider] = useState<DataProvider | any>();\n\n  // try to guess the auth type based on config, otherwise specified\n  const buildDataProvider = async (authType: AUTH_TYPE) => {\n    const auth = getAuthType(config, authType);\n    return await buildAmplifyProvider({\n      endpoint: config.aws_appsync_graphqlEndpoint,\n      auth: {\n        url: config.aws_appsync_graphqlEndpoint,\n        region: config.aws_appsync_region,\n        auth,\n      },\n      schema,\n      queries,\n      mutations,\n    });\n  };\n\n  /** Rebuild dataProvider */\n  const user = useUser();\n  let specifiedAuthType = authType || config.aws_appsync_authenticationType;\n\n  useEffect(() => {\n    // if (specifiedAuthType === AUTH_TYPE.AMAZON_COGNITO_USER_POOLS && !user) {\n    //   return;\n    // }\n\n    buildDataProvider(specifiedAuthType).then(dataProvider =>\n      setDataProvider(() => dataProvider)\n    );\n  }, [user, specifiedAuthType]);\n\n  return dataProvider;\n}\n","import { AUTH_TYPE, AuthOptions } from 'aws-appsync-auth-link';\nimport { Auth } from 'aws-amplify';\n\nexport const getAuthType = (\n  config: Record<string, any>,\n  specifiedAuthType?: AUTH_TYPE | undefined\n): AuthOptions => {\n  const authType =\n    specifiedAuthType ||\n    config.aws_appsync_authenticationType ||\n    AUTH_TYPE.NONE;\n  switch (authType) {\n    case AUTH_TYPE.AMAZON_COGNITO_USER_POOLS:\n      return {\n        // @ts-ignore\n        type: AUTH_TYPE.AMAZON_COGNITO_USER_POOLS,\n        jwtToken: async () => {\n          try {\n            return (await Auth.currentSession()).getAccessToken().getJwtToken();\n          } catch (error) {\n            console.log('error with jwt', error);\n            return Promise.reject('Unauthorized');\n          }\n        },\n      };\n\n    case AUTH_TYPE.API_KEY:\n      return {\n        type: AUTH_TYPE.API_KEY,\n        apiKey: config.aws_appsync_apiKey,\n      };\n    case AUTH_TYPE.NONE:\n    default:\n      return {\n        type: AUTH_TYPE.NONE,\n      };\n  }\n};\n"],"names":["getFinalType","type","kind","TypeKind","NON_NULL","LIST","ofType","cleanS3Object","input","fields","Object","entries","reduce","acc","k","v","includes","sanitizeResource","data","keys","key","startsWith","dataKey","Array","isArray","map","d","id","buildVariablesImpl","getGqlQuery","getResponseParserImpl","queries","mutations","introspectionResults","knownResources","resources","r","name","aorFetchType","resourceName","params","console","log","resource","find","Error","join","queryType","variables","preparedParams","prepareParams","result","forEach","param","arg","args","item","File","Date","toISOString","types","inputFields","value","Number","String","Boolean","castType","GET_LIST","_aorFetchType","token","filter","nextToken","pagination","page","undefined","buildGetListVariables","GET_MANY","ids","i","GET_MANY_REFERENCE","query","q","target","limit","perPage","GET_ONE","DELETE","CREATE","UPDATE","_resource","_fetchType","inputArgument","a","inputTypeName","t","inputField","f","_getFinalType$name","match","cleanS3Param","buildCreateUpdateVariables","raFetchType","gql","parseResponse","response","items","total","buildQueryFactory","SINGLE_OPERATION_MAP","UPDATE_MANY","DELETE_MANY","defaultOptions","introspection","operationNames","exclude","include","buildAmplifyProvider","schema","options","client","auth","httpLink","createHttpLink","uri","endpoint","awsLink","createAppSyncLink","fragmentMatcher","IntrospectionFragmentMatcher","introspectionQueryResultData","__schema","ApolloClient","link","concat","cache","InMemoryCache","createClient","buildQuery","defaultBuildQuery","merge","buildGraphQLProvider","then","defaultDataProvider","fetchType","otherParams","Promise","all","results","_","idx","_catch","body","recover","e","Symbol","iterator","asyncIterator","AmplifyAuthContext","React","createContext","UserContext","useUser","useContext","nextTokenReducer","previousState","CRUD_GET_LIST_SUCCESS","payload","S3Field","source","record","children","props","useState","src","set","identityId","level","useEffect","Storage","get","CircularProgress","childProps","cloneElement","defaultProps","addLabel","useStyles","makeStyles","theme","icon","marginRight","spacing","S3File","s3Object","Icon","ImageIcon","MovieIcon","DescriptionIcon","getIcon","classes","titleAccess","className","Link","href","title","S3FileField","S3Image","imgProps","S3ImageField","S3Input","dropzoneOptions","permissions","usePermissions","useInput","notify","useNotify","onDrop","files","file","nameParts","split","put","uuid","slice","claims","onChange","multiple","fileInput","display","alignItems","reducers","user","setUser","Auth","currentAuthenticatedUser","listener","event","Hub","listen","remove","Provider","useSelector","state","Toolbar","Button","color","startIcon","ChevronLeft","onClick","setPage","endIcon","ChevronRight","FileInput","ImageInput","config","authType","dataProvider","setDataProvider","specifiedAuthType","aws_appsync_authenticationType","AUTH_TYPE","NONE","AMAZON_COGNITO_USER_POOLS","jwtToken","currentSession","_Auth$currentSession","getAccessToken","getJwtToken","error","reject","API_KEY","apiKey","aws_appsync_apiKey","getAuthType","aws_appsync_graphqlEndpoint","url","region","aws_appsync_region","buildDataProvider","context","login","username","password","provider","signIn","federatedSignIn","logout","signOut","checkAuth","checkError","currentCredentials","getPermissions","getIdToken"],"mappings":"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"}